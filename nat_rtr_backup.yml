---
- name: MikroTik minimal backup (.backup + single .rsc)
  hosts: NAT_RTR
  gather_facts: no

  vars:
    backup_base_dir: "/root/network/backups/NAT_RTR"   # local (Semaphore/controller)
    retention_keep: 10
    ssh_args_common: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"

  pre_tasks:
    - name: Ensure per-host backup directory exists (local)
      delegate_to: localhost
      ansible.builtin.file:
        path: "{{ backup_base_dir }}/{{ inventory_hostname }}"
        state: directory
        mode: "0750"

    - name: Set backup timestamp (local)
      delegate_to: localhost
      ansible.builtin.set_fact:
        backup_ts: "{{ lookup('pipe', 'date +%Y%m%d-%H%M%S') }}"

    - name: Ensure SSH port is defined (default 22)
      ansible.builtin.set_fact:
        ansible_port: "{{ ansible_port | default(22) }}"

    # ----- sshpass handling (only if password auth) -----
    - name: Gather localhost facts to detect package manager
      when: ansible_ssh_pass is defined
      delegate_to: localhost
      run_once: true
      ansible.builtin.setup:

    - name: Record local package manager
      when: ansible_ssh_pass is defined
      delegate_to: localhost
      run_once: true
      ansible.builtin.set_fact:
        local_pkg_mgr: "{{ ansible_facts.pkg_mgr | default(ansible_facts.ansible_pkg_mgr | default('unknown')) }}"

    - name: Install sshpass via APT (Debian/Ubuntu)
      when:
        - ansible_ssh_pass is defined
        - local_pkg_mgr in ['apt', 'apt-get']
      delegate_to: localhost
      run_once: true
      become: yes
      ansible.builtin.apt:
        name: sshpass
        state: present
        update_cache: yes

    - name: Enable EPEL (RHEL/CentOS) if needed
      when:
        - ansible_ssh_pass is defined
        - local_pkg_mgr == 'yum'
      delegate_to: localhost
      run_once: true
      become: yes
      ansible.builtin.yum:
        name: epel-release
        state: present

    - name: Install sshpass via YUM (RHEL/CentOS)
      when:
        - ansible_ssh_pass is defined
        - local_pkg_mgr == 'yum'
      delegate_to: localhost
      run_once: true
      become: yes
      ansible.builtin.yum:
        name: sshpass
        state: present

    - name: Install sshpass via DNF (Fedora/Rocky/Alma modern)
      when:
        - ansible_ssh_pass is defined
        - local_pkg_mgr == 'dnf'
      delegate_to: localhost
      run_once: true
      become: yes
      ansible.builtin.dnf:
        name: sshpass
        state: present

  tasks:
    # ---------- Export on router (ONE-LINE) ----------
    - name: Export single config (.rsc) on router (key auth)
      delegate_to: localhost
      when: ansible_ssh_pass is not defined
      ansible.builtin.shell: >
        ssh -p {{ ansible_port }} {{ ssh_args_common }} {{ ansible_user }}@{{ inventory_hostname }}
        "/export file={{ inventory_hostname }}_config_{{ backup_ts }}"
      changed_when: true

    - name: Export single config (.rsc) on router (password auth)
      delegate_to: localhost
      when: ansible_ssh_pass is defined
      ansible.builtin.shell: >
        sshpass -p '{{ ansible_ssh_pass }}' ssh -p {{ ansible_port }} {{ ssh_args_common }}
        {{ ansible_user }}@{{ inventory_hostname }}
        "/export file={{ inventory_hostname }}_config_{{ backup_ts }}"
      changed_when: true

    - name: Create full binary backup (.backup) on router (key auth)
      delegate_to: localhost
      when: ansible_ssh_pass is not defined
      ansible.builtin.shell: >
        ssh -p {{ ansible_port }} {{ ssh_args_common }} {{ ansible_user }}@{{ inventory_hostname }}
        "/system/backup/save name={{ inventory_hostname }}_full_{{ backup_ts }} dont-encrypt=yes"
      changed_when: true

    - name: Create full binary backup (.backup) on router (password auth)
      delegate_to: localhost
      when: ansible_ssh_pass is defined
      ansible.builtin.shell: >
        sshpass -p '{{ ansible_ssh_pass }}' ssh -p {{ ansible_port }} {{ ssh_args_common }}
        {{ ansible_user }}@{{ inventory_hostname }}
        "/system/backup/save name={{ inventory_hostname }}_full_{{ backup_ts }} dont-encrypt=yes"
      changed_when: true

    # ---------- Copy back to controller ----------
    - name: Copy config export to controller (key auth)
      delegate_to: localhost
      when: ansible_ssh_pass is not defined
      ansible.builtin.shell: >
        scp -P {{ ansible_port }} {{ ssh_args_common }}
        {{ ansible_user }}@{{ inventory_hostname }}:/{{ inventory_hostname }}_config_{{ backup_ts }}.rsc
        "{{ backup_base_dir }}/{{ inventory_hostname }}/"

    - name: Copy config export to controller (password auth)
      delegate_to: localhost
      when: ansible_ssh_pass is defined
      ansible.builtin.shell: >
        sshpass -p '{{ ansible_ssh_pass }}' scp -P {{ ansible_port }} {{ ssh_args_common }}
        {{ ansible_user }}@{{ inventory_hostname }}:/{{ inventory_hostname }}_config_{{ backup_ts }}.rsc
        "{{ backup_base_dir }}/{{ inventory_hostname }}/"

    - name: Copy full binary backup to controller (key auth)
      delegate_to: localhost
      when: ansible_ssh_pass is not defined
      ansible.builtin.shell: >
        scp -P {{ ansible_port }} {{ ssh_args_common }}
        {{ ansible_user }}@{{ inventory_hostname }}:/{{ inventory_hostname }}_full_{{ backup_ts }}.backup
        "{{ backup_base_dir }}/{{ inventory_hostname }}/"

    - name: Copy full binary backup to controller (password auth)
      delegate_to: localhost
      when: ansible_ssh_pass is defined
      ansible.builtin.shell: >
        sshpass -p '{{ ansible_ssh_pass }}' scp -P {{ ansible_port }} {{ ssh_args_common }}
        {{ ansible_user }}@{{ inventory_hostname }}:/{{ inventory_hostname }}_full_{{ backup_ts }}.backup
        "{{ backup_base_dir }}/{{ inventory_hostname }}/"

    # ---------- Cleanup on router (each as separate command; non-fatal) ----------
    - name: Cleanup config .rsc from router (key auth)
      delegate_to: localhost
      when: ansible_ssh_pass is not defined
      ansible.builtin.shell: >
        ssh -p {{ ansible_port }} {{ ssh_args_common }} {{ ansible_user }}@{{ inventory_hostname }}
        "/file remove \"{{ inventory_hostname }}_config_{{ backup_ts }}.rsc\"" || true
      changed_when: true

    - name: Cleanup full .backup from router (key auth)
      delegate_to: localhost
      when: ansible_ssh_pass is not defined
      ansible.builtin.shell: >
        ssh -p {{ ansible_port }} {{ ssh_args_common }} {{ ansible_user }}@{{ inventory_hostname }}
        "/file remove \"{{ inventory_hostname }}_full_{{ backup_ts }}.backup\"" || true
      changed_when: true

    - name: Cleanup config .rsc from router (password auth)
      delegate_to: localhost
      when: ansible_ssh_pass is defined
      ansible.builtin.shell: >
        sshpass -p '{{ ansible_ssh_pass }}' ssh -p {{ ansible_port }} {{ ssh_args_common }}
        {{ ansible_user }}@{{ inventory_hostname }}
        "/file remove \"{{ inventory_hostname }}_config_{{ backup_ts }}.rsc\"" || true
      changed_when: true

    - name: Cleanup full .backup from router (password auth)
      delegate_to: localhost
      when: ansible_ssh_pass is defined
      ansible.builtin.shell: >
        sshpass -p '{{ ansible_ssh_pass }}' ssh -p {{ ansible_port }} {{ ssh_args_common }}
        {{ ansible_user }}@{{ inventory_hostname }}
        "/file remove \"{{ inventory_hostname }}_full_{{ backup_ts }}.backup\"" || true
      changed_when: true

    # ---------- Retention (local) ----------
    - name: Retain only last N files (local)
      delegate_to: localhost
      changed_when: false
      vars:
        keep: "{{ retention_keep }}"
        base: "{{ backup_base_dir }}/{{ inventory_hostname }}"
      ansible.builtin.shell: |
        ls -1t "{{ base }}/{{ inventory_hostname }}_config_*.rsc"  2>/dev/null | awk 'NR>{{ keep }}' | xargs -r rm -f
        ls -1t "{{ base }}/{{ inventory_hostname }}_full_*.backup" 2>/dev/null | awk 'NR>{{ keep }}' | xargs -r rm -f
